// Original Tasmota driver developed by Brett Sheleski
// Ported to Hubitat by dkkohler
// HSB Color Settings by Eric Maycock (erocm123)
// Modified to work with the tasmota firmware for RGBW LED Light Bulbs using the SYF05 Configuration by damondins
// Hubitat driver for controlling the tasmota firmware for RGBW LED Light Bulbs using the SYF05 Configuration
// Version 1.0.5 Fixed Hue Value Math
// Version 1.0.4 Merged Color Temperature support
// Version 1.0.3 Added Support for LED Schemes
// Version 1.0.2 Added Support for Level Duration - Duration can be set from 0 to 7
// Version 1.0.1 Fixed capturing the CT commands from Groups & Scenes when asking for a white color
// Version 1.0.0

metadata {
	definition(name: "Tasmota RGBCT LED Light Bulb", namespace: "Obi2000", author: "Obi2000") {
		capability "Switch"
		capability "ColorControl"
        capability "ColorTemperature"
		capability "Light"
		capability "SwitchLevel"
        capability "ColorMode"
        capability "Refresh"
		
		attribute "colorName", "string"
        
        command "white"
        command "ModeNext"
        command "ModePrevious"
        command "ModeSingleColor"
        command "ModeWakeUp"
        command "ModeCycleUpColors"
        command "ModeCycleDownColors"
        command "ModeRandomColors"
    }

	preferences {		
		section("Sonoff Host") {
            input(name: "ipAddress", type: "string", title: "IP Address", displayDuringSetup: true, required: true)
			input(name: "port", type: "number", title: "Port", displayDuringSetup: true, required: true, defaultValue: 80)
		}

		section("Authentication") {
			input(name: "username", type: "string", title: "Username", displayDuringSetup: false, required: false)
			input(name: "password", type: "password", title: "Password (sent cleartext)", displayDuringSetup: false, required: false)
		}

   		section("Configuration") {
            
            input(name: "TWlow", type: "string", title: "Tuneable White Low Level", displayDuringSetup: true, required: true, defaultValue: 2200)
			input(name: "TWhigh", type: "string", title: "Tuneable White High Level", displayDuringSetup: true, required: true, defaultValue: 7000)
		}
		
		section("Settings") {
			//input(name: "fade", type: "bool", title: "Fade", displayDuringSetup: false, required: false, defaultValue: false)
		}   
		
	}
}

def parse(String description) {
	def message = parseLanMessage(description)
	def isParsed = false;

	// parse result from current formats
	def resultJson = {}
	if (message?.json) {
		// current json data format
		resultJson = message.json
        log.debug resultJson
	}  
}

def on() {
    sendEvent(name: "switch", value: "on")
	sendCommand("Power", "On")
}

def off() {
    sendEvent(name: "switch", value: "off")
	sendCommand("Power", "Off")
}

def setColorTemperature(value)
{
	state.colorMode = "CT"
	sendEvent(name: "colorMode", value: "CT")
	log.debug "ColorTemp = " + value
	def intvalue = value.toInteger()
	def intTWlow = TWlow.toInteger()
	def intTWhigh = TWhigh.toInteger()
	
	def kelvindiff = intTWhigh - intTWlow
	def tasmotadiff = 348
	def kelvinscale = kelvindiff / tasmotadiff
	kelvinscale = Math.round(kelvinscale)
	convertedvalue =  intvalue / kelvinscale
	flipvalue = 153 + (500 - convertedvalue) 
	flipvalue = Math.round(flipvalue)
	
    sendEvent(name: "colorTemperature", value: intvalue)
    
	if (flipvalue < 153) {
        sendEvent(name: "Temp", value: intvalue)
        sendEvent(name: "colorName", value: "Cool White")
		sendCommand("CT", "153")
	} else if (flipvalue > 500) {
        sendEvent(name: "Temp", value: 500)
		sendEvent(name: "colorName", value: "Warm White")
        sendCommand("CT", "500")
	} else {
        //sendEvent(name: "Temp", value: value)
        if (value < 2600) {
            sendEvent(name: "colorName", value: "Warm White")
        }
        else if (value < 3500) {
            sendEvent(name: "colorName", value: "Incandescent")
        }
        else if (value < 4500) {
            sendEvent(name: "colorName", value: "White")
        }
        else if (value < 5500) {
            sendEvent(name: "colorName", value: "Daylight")
        }
        else if (value >=  5500) {
            sendEvent(name: "colorName", value: "Cool White")
        }
        
		sendCommand("CT", "$flipvalue")
	}
}   









    
def setColor(value) {
	log.debug "HSBColor = "+ value
	   if (value instanceof Map) {
        def h = value.containsKey("hue") ? value.hue : null
        def s = value.containsKey("saturation") ? value.saturation : null
        def b = value.containsKey("level") ? value.level : null
    	setHsb(h, s, b)
    } else {
        log.warn "Invalid argument for setColor: ${value}"
    }
}

def setHsb(h,s,b)
{
	log.debug("setHSB - ${h},${s},${b}")
	myh = h*3.6
	if( myh > 360 ) { myh = 360 }
	hsbcmd = "${myh},${s},${b}"
	log.debug "Cmd = ${hsbcmd}"
    state.hue = h
	state.saturation = s
	state.level = b
	state.colorMode = "RGB"
    sendEvent(name: "hue", value: "${h}")
    sendEvent(name: "saturation", value: "${s}")
    sendEvent(name: "level", value: "${b}")
	if (hsbcmd == "0,0,100") {
        state.colorMode = "CT"
        sendEvent(name: "colorMode", value: "CT")
        white()
        }
    else {
        sendEvent(name: "colorMode", value: "RGB")
        sendCommand("hsbcolor", hsbcmd)
    }
}

def setHue(h)
{
    setHsb(h,state.saturation,state.level)
}

def setSaturation(s)
{
	setHsb(state.hue,s,state.level)
}

def setLevel(v)
{
    setLevel(v, 0)
}

def setLevel(v, duration)
{
    sendEvent(name: "level", value: "${v}")
    if (duration == 0) {
        if (state.colorMode == "RGB") {
            setHsb(state.hue,state.saturation, v)    
        }
        else {
            sendCommand("Dimmer", "${v}")
        }
    }
    else if (duration > 0) {
        if (state.colorMode == "RGB") {
            setHsb(state.hue,state.saturation, v)    
        }
        else {
            if (duration > 7) {duration = 7}
            cdelay = duration * 10
            DurCommand = "fade%201%3Bspeed%20" + "$duration" + "%3Bdimmer%20" + "$v" + "%3BDelay%20"+ "$cdelay" + "%3Bfade%200"
            sendCommand("backlog", DurCommand)
        }
   }
}

def white() {
    sendEvent(name: "hue", value: "0")
    sendEvent(name: "saturation", value: "100")
    sendEvent(name: "level", value: "100")
	sendEvent(name: "colorMode", value: "CT")
    state.hue = state.hue
	state.saturation = state.saturation
	state.level = state.level
    state.colorMode = "CT"
    def lvl = state.level
    if (lvl < 1) {
        lvl = 1
    }
    lvl = lvl * 2.55
    lvl = Math.round(lvl)
    lvl = lvl.toInteger()
    lvl = lvl.toHexString(lvl)
    
    sendCommand("color", "000000" + "$lvl")
}

def ModeNext() {
    if (state.mode < 4) {
        state.mode = state.mode + 1
    }
    else {
        state.mode = 0
    }
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "${state.mode}")
}

def ModePrevious() {
    if (state.mode > 0) {
        state.mode = state.mode - 1
    }
    else {
        state.mode = 4
    }
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "${state.mode}")
}

def ModeSingleColor() {
    state.mode = 0
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "0")
}

def ModeWakeUp() {
    state.mode = 1
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "1")
}

def ModeCycleUpColors() {
    state.mode = 2
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "2")
}

def ModeCycleDownColors() {
    state.mode = 3
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "3")
}

def ModeRandomColors() {
    state.mode = 4
    sendEvent(name: "mode", value: "${state.mode}")
    sendCommand("Scheme", "4")
}

private def sendCommand(String command, payload) {
    sendCommand(command, payload.toString())
}

private def sendCommand(String command, String payload) {
	//log.debug "sendCommand(${command}:${payload}) to device at $ipAddress:$port"

	if (!ipAddress || !port) {
		log.warn "aborting. ip address or port of device not set"
		return null;
	}
	def hosthex = convertIPtoHex(ipAddress)
	def porthex = convertPortToHex(port)

	def path = "/cm"
	if (payload){
		path += "?cmnd=${command}%20${payload}"
	}
	else{
		path += "?cmnd=${command}"
	}

	if (username){
		path += "&user=${username}"
		if (password){
			path += "&password=${password}"
		}
	}

	def result = new hubitat.device.HubAction(
		method: "GET",
		path: path,
		headers: [
			HOST: "${ipAddress}:${port}"
		]
	)

    return result
}

private String convertIPtoHex(ipAddress) { 
	String hex = ipAddress.tokenize( '.' ).collect {  String.format( '%02x', it.toInteger() ) }.join()
	return hex
}

private String convertPortToHex(port) {
	String hexport = port.toString().format('%04x', port.toInteger())
	return hexport
}


def refresh() {

    
}

